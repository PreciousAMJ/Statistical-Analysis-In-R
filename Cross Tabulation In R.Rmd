---
title: "Cross Tabulation"
output:
---



----



Load the dataset
```{r}
Diabetes_Dataset <- read.csv("C:/Users/HP/Documents/Datasets/Diabetes Dataset.csv")

View(Diabetes_Dataset)

dim(Diabetes_Dataset) # To get the num of rows and columns

dimnames(Diabetes_Dataset)[[2]] # There are two parts to the dimnames object: names of the rows, which is generally not useful, and names of the columns, which definitely is. You just want the second of those, hence the “[[2]]” bit. This gives the same output, but just the column names
```



To do any analysis, my preference is to make one variable per column rather than refer directly to the column within the data set every time. Not all of the columns are very interesting, though, so don’t bother with “id” for example. We’re not going to use it. When doing this, you need to tell R which variables are categorical, as it will assume they’re all continuous by default:
```{r}
Cholesterol <- Diabetes_Dataset$chol # cholesterol is continous

Gender <- as.factor(Diabetes_Dataset$gender) # gender is not continous, so we let R recognise it as a category by using the "as.factor" funtion

Outcome <- as.factor(Diabetes_Dataset$dm) # same for Outcome
```



To see how many males and females we have, you can use the “table” command. It’s worth also getting the total:
```{r}
t <- table(Gender) # it'll give the count of the distinct values in the column gender, we store the tabulation for future manipulation
t

addmargins(t) # it'll give the overall totals
```



Annoyingly, it doesn’t give the percentages of any of the categories, a really basic analysis task. With the tabulation stored as an R object, though, we can do this quite simply using the “prop.table” command:
The "round" funtion rounds a number into specified number of digits
The "prop.table" funtion gives the proportion of each distinct values/category of a table
```{r}
prop.table(t) # to get the proportion of each distinct values in the column

100*prop.table(t) # to get the proportion in %

round(100*prop.table(t), digits = 1) # gets the % rounded to 1dp
```



 “table” *excludes missing values by default*. To see these – and we ALWAYS want to see these – use an “exclude=NULL” option when making the variable:
```{r}
Outcome2 <- factor(Outcome, exclude=NULL) # make new factor from the old one

table(Outcome2) # display the counts including the missings (NAs)


```
 
 

# Let's continue with other variables
```{r}
Height <- Diabetes_Dataset$height

Weight <- Diabetes_Dataset$weight

summary(Height) # note summary command gives us the missing values by default

summary(Weight)
```
Note, unlike "table", "summary" command will include the null values



----
## How to calculate body mass index (BMI) from height and weight

As this is a US data set, height is in inches and weight is in pounds. Neither height nor weight are particularly useful by themselves, however, so it’s common to combine them into the body mass index (BMI), which is weight divided by the square of height; both measures need to be in SI units, i.e. kilograms and metres, so we need to convert:
```{r}
Height.si <- Height*0.0254

Weight.si <- Weight*0.453592

BMI <- Weight.si/Height.si^2

summary(BMI)
```



## How to make a categorical variable from a continuous one

For display purposes and also because thresholds are used in clinical decision-making, it’s useful to categorise continuous variables even though this loses information. For instance, it’s very common to categorise BMI. One reason is so that public health agencies can track the numbers of people and proportion of the population who are obese, for example. Tracking the mean or median BMI for the population won’t tell you this. There are several ways to categorise BMI in R. Here’s one way. Let’s say we want groups for underweight [<18.5], normal [18.5-25], overweight [>25] and obese [>30]; a morbidly obese category also exists but let’s ignore that here.
```{r}
BMI_Categorised <- ifelse(BMI < 18.5, "Underweight",
                          ifelse(BMI >=18.5 & BMI <= 25, "Normal",
                                 ifelse(BMI > 25 & BMI <= 30, "Overweight",
                                        ifelse(BMI > 30, "Obese", NA))))
#Note the way the ifelse are nested - the "else" (no) part of a ifelse is another ifelse. 
```



Let's use "table" to see the distinct values of each of the category
```{r}
table(BMI_Categorised, exclude = NULL)
```



Create a cross tabulation to view the diabetes outcome for each BMI category
```{r}
Outcome_by_BMI <- table(BMI_Categorised, Outcome2, exclude = NULL)

Outcome_by_BMI
```



In the function prop.table(), using the argument margin = 1 we can specify that the table gives us the *row* proportion, i.e. the proportion of each column (diabetes status) in each row (BMI category). If we entered margin = 2, this would display the inverse, i.e. the proportion of each row in each column.
```{r}
prop.table(Outcome_by_BMI, margin = 1) # to get the proportion of the outcome for each bmi category

100 * prop.table(Outcome_by_BMI, margin = 1)

round(100 * prop.table(Outcome_by_BMI, margin = 1), digits = 1)
```


